<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>作业5</title>
    <link href="/blog/2025/01/20/%E4%BD%9C%E4%B8%9A5/"/>
    <url>/blog/2025/01/20/%E4%BD%9C%E4%B8%9A5/</url>
    
    <content type="html"><![CDATA[<p><strong>一、Maven 相关</strong></p><ul><li>理解分模块开发的意义<ul><li>提高代码的可维护性：将一个大型项目划分为多个模块，可以使代码结构更加清晰，不同模块负责不同的功能，便于开发人员理解和维护。</li><li>促进团队协作：不同的团队或开发人员可以负责不同的模块，并行开发，提高开发效率。</li><li>代码复用：可以将一些通用的功能封装在独立的模块中，在多个项目或模块中复用，避免重复开发。</li><li>易于测试和部署：可以对单个模块进行测试和部署，减少整体测试和部署的复杂性。</li></ul></li><li>如何分模块开发及步骤<ol><li>确定模块划分：根据功能、业务逻辑或架构等因素，将项目划分为多个模块，例如可以将业务逻辑、数据访问、公共工具等划分为不同模块。</li><li>创建模块：在项目的 <code>pom.xml</code> 文件中，使用 <code>&lt;modules&gt;</code> 元素添加子模块。例如：</li></ol></li></ul><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>module1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>module2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>为每个模块创建独立的 <code>pom.xml</code>：在每个模块的根目录下创建 <code>pom.xml</code> 文件，定义模块的依赖、构建信息等。</li><li>配置模块间的依赖：在需要使用其他模块的模块的 <code>pom.xml</code> 中，使用 <code>&lt;dependency&gt;</code> 元素添加对其他模块的依赖。例如：</li></ol><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>module1<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>如何跳过测试<ul><li>在 Maven 命令中添加 <code>-DskipTests</code> 参数，例如 <code>mvn install -DskipTests</code>，这样在构建过程中会跳过单元测试。</li><li>也可以在 <code>pom.xml</code> 中配置 <code>&lt;skipTests&gt;</code> 元素，例如：</li></ul></li></ul><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">skipTests</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skipTests</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>二、Spring Boot 相关</strong></p><ul><li>开发案例：在网页中打印一句字符串<ul><li>首先，使用 Spring Initializr 创建一个 Spring Boot 项目，添加 <code>spring-boot-starter-web</code> 依赖。</li><li>创建一个控制器类，例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>启动 Spring Boot 应用，访问 <code>http://localhost:8080/hello</code>，即可在网页中看到打印的字符串。</li><li>解释：<ul><li><code>@RestController</code> 注解将该类标记为控制器，并且其中的方法返回的是数据而不是视图。</li><li><code>@GetMapping(&quot;/hello&quot;)</code> 注解表示该方法处理 <code>/hello</code> 路径的 GET 请求。</li></ul></li><li>构建 Spring Boot 工程的步骤总结（通过入门案例）<ol><li>使用 Spring Initializr 选择项目所需的依赖，如 <code>spring-boot-starter-web</code> 等，生成项目骨架。</li><li>在 <code>src/main/java</code> 目录下创建控制器、服务等组件。</li><li>配置 <code>application.properties</code> 或 <code>application.yml</code> 文件（可选）。</li><li>运行 <code>SpringApplication.run(Application.class, args);</code> 启动应用。</li></ol></li><li>Spring Boot 官网创建方式<ul><li>访问 Spring Boot 官网的 Spring Initializr 页面（<a href="https://start.spring.io/%EF%BC%89%E3%80%82">https://start.spring.io/）。</a></li><li>选择项目的元数据，如项目类型（Maven 或 Gradle）、语言（Java、Kotlin 等）、Spring Boot 版本、项目的坐标等。</li><li>选择所需的依赖，如 Web、JPA、MyBatis 等。</li><li>点击生成项目，下载并导入到 IDE 中进行开发。</li></ul></li><li>配置文件的写法、内容、格式及 YML 文件<ul><li><strong><code>application.properties</code> 格式</strong>：使用 <code>key=value</code> 的形式，例如 <code>server.port=8080</code>。</li><li><strong><code>application.yml</code> 格式</strong>：使用 YAML 格式，例如：</li></ul></li></ul><p>yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><ul><li>配置文件可以包含服务器配置（如端口号、上下文路径）、数据库连接信息、日志配置等。</li><li>YML 文件（YAML）是一种更简洁和易读的数据序列化格式，支持层次结构。</li><li>多环境开发配置<ul><li>在 <code>application.yml</code> 或 <code>application.properties</code> 中，可以使用 <code>spring.profiles.active</code> 属性指定激活的环境，例如 <code>spring.profiles.active=dev</code>。</li><li>可以创建多个配置文件，如 <code>application-dev.yml</code>、<code>application-prod.yml</code> 等，根据不同环境存储不同的配置信息。例如：</li></ul></li></ul><p>yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># application-dev.yml</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment"># application-prod.yml</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><ul><li>Spring Boot 整合 JUnit<ul><li>首先，添加 <code>spring-boot-starter-test</code> 依赖。</li><li>编写测试类，使用 <code>@SpringBootTest</code> 注解，例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootJUnitTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 测试逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>解释：<ul><li><code>@SpringBootTest</code> 注解会加载整个 Spring Boot 应用上下文，以便进行集成测试。</li><li>可以使用 <code>@Autowired</code> 注入需要测试的组件，如服务、控制器等。</li></ul></li><li>Spring Boot 整合 MyBatis<ul><li>首先，添加 <code>mybatis-spring-boot-starter</code> 和相应数据库驱动的依赖，例如：</li></ul></li></ul><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>配置 <code>application.yml</code> 或 <code>application.properties</code> 中的数据源信息，例如：</li></ul><p>yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/dbname</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><ul><li>创建 Mapper 接口，使用 <code>@Mapper</code> 注解，例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM users&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在服务中使用 Mapper 接口，例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.findAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>解释：<ul><li><code>@Mapper</code> 注解将接口标记为 MyBatis 的 Mapper，Spring 会自动生成实现类。</li><li><code>@Select</code> 注解定义 SQL 查询语句，MyBatis 会将其映射到对应的数据库操作。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作业4</title>
    <link href="/blog/2025/01/19/%E4%BD%9C%E4%B8%9A4/"/>
    <url>/blog/2025/01/19/%E4%BD%9C%E4%B8%9A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong>SpringMVC简介 P43-P46</strong></p><ul><li><p><strong>建立一个SpringMVC项目（了解即可，学完SpringBoot之后一键创建，但是现在你们需要手动创建来学习下面的内容）</strong></p><p>SpringMVC 是一种基于 Java 的实现了 Web MVC 设计模式的请求驱动型轻量级 Web 框架，即使用了 MVC 架构模式的思想，将 Web 层进行职责解耦，把复杂的 Web 应用分成模型（Model）、视图（View）和控制器（Controller）三个部分，以提高代码的可维护性、可扩展性和可测试性。</p></li></ul></li><li><p><strong>接口请求工具 P47</strong></p><ul><li><strong>可根据视频教程使用PostMan，但是我们在实际开发中会使用更现代化的工具apifox</strong></li><li><strong>所以各位可以根据自己实际情况二选一（apifox早晚得学）</strong></li></ul></li><li><p><strong>什么是Get请求？什么是POST请求? P48-P49</strong></p><ul><li><p><strong>如何在Postman或apifox里面发送get或者post请求？</strong></p></li><li><p><strong>如何在请求工具设置请求参数？</strong></p></li><li><p><strong>后端如何设置接收刚刚的参数？</strong></p><ol><li>GET 请求和 POST 请求的定义<ul><li><strong>GET 请求</strong>：是 HTTP 协议中最常用的请求方法之一。它主要用于从服务器获取资源，请求的参数通常附加在 URL 的后面，以 “? 参数名 &#x3D; 参数值 &amp; 参数名 &#x3D; 参数值…” 的形式存在，并且这些参数会显示在浏览器的地址栏中。例如，<code>https://example.com/api/users?page=1&amp;limit=10</code>，这里<code>page=1</code>和<code>limit=10</code>就是 GET 请求的参数。GET 请求的参数有长度限制，不同浏览器和服务器对其限制有所不同，一般在 2048 个字符左右。由于参数暴露在 URL 中，所以 GET 请求不太适合传输敏感信息。</li><li><strong>POST 请求</strong>：用于向服务器提交数据，通常用于创建或更新资源。它的参数不会显示在 URL 中，而是放在请求体（Request Body）中。这种方式更适合传输大量数据或敏感信息，因为参数不直接暴露在地址栏中，并且没有像 GET 请求那样严格的长度限制。例如，在用户注册时，提交用户名、密码等信息通常使用 POST 请求。</li></ul></li><li>在 Postman 或 Apifox 里面发送 GET 或者 POST 请求<ul><li>在 Postman 中发送请求<ul><li><strong>发送 GET 请求</strong>：打开 Postman 应用，在请求类型下拉框中选择 “GET”，在地址栏中输入目标 URL，若有参数，可在地址栏中直接以 “? 参数名 &#x3D; 参数值 &amp;…” 的形式添加，然后点击 “Send” 按钮发送请求。</li><li><strong>发送 POST 请求</strong>：在请求类型下拉框中选择 “POST”，输入目标 URL。若需要传递参数，切换到 “Body” 选项卡，根据参数类型选择 “raw”（用于 JSON、XML 等格式）、“form-data”（用于表单数据）或 “x - www - form - urlencoded”（也是用于表单数据），然后在相应区域填写参数和值，最后点击 “Send” 按钮。</li></ul></li><li>在 Apifox 中发送请求<ul><li><strong>发送 GET 请求</strong>：打开 Apifox，创建一个新的接口，在请求方法下拉框中选择 “GET”，在地址栏输入目标 URL，若有参数，可在 “Query” 选项卡中添加参数，输入参数名和参数值，点击 “发送” 按钮。</li><li><strong>发送 POST 请求</strong>：选择 “POST” 请求方法，输入 URL。在 “Body” 选项卡中，根据参数类型选择 “JSON”、“表单数据（Form - Data）” 或 “URL 编码（x - www - form - urlencoded）”，填写相应的参数和值后，点击 “发送” 按钮。</li></ul></li></ul></li><li>在请求工具设置请求参数<ul><li><strong>GET 请求参数设置</strong>：在 Postman 和 Apifox 中，对于 GET 请求，参数主要在地址栏或 “Query” 选项卡中设置。在地址栏中直接以 “? 参数名 &#x3D; 参数值 &amp;…” 的形式添加；在 “Query” 选项卡中，逐行输入参数名和对应的参数值。</li><li>POST 请求参数设置<ul><li><strong>JSON 格式</strong>：在 Postman 和 Apifox 的 “Body” 选项卡中选择 “raw”，然后选择 “JSON” 格式，在文本框中输入符合 JSON 语法的参数数据，如<code>&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;</code>。</li><li><strong>表单数据（Form - Data）</strong>：在 “Body” 选项卡中选择 “form - data”，点击 “添加字段” 按钮，输入参数名和参数值，可添加多个字段。</li><li><strong>URL 编码（x - www - form - urlencoded）</strong>：在 “Body” 选项卡中选择 “x - www - form - urlencoded”，同样点击 “添加字段” 按钮，输入参数名和参数值。</li></ul></li></ul></li><li>后端如何设置接收刚刚的参数<ul><li><strong>接收 GET 请求参数</strong>：</li></ul></li></ol><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/users&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsers</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name = &quot;page&quot;, required = false, defaultValue = &quot;1&quot;)</span> <span class="hljs-type">int</span> page,</span><br><span class="hljs-params">                           <span class="hljs-meta">@RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;)</span> <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-comment">// 处理业务逻辑，这里简单返回参数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Page: &quot;</span> + page + <span class="hljs-string">&quot;, Limit: &quot;</span> + limit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>接收 POST 请求参数（以 JSON 格式为例）</strong>：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 省略 getters 和 setters</span><br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/users&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>        <span class="hljs-comment">// 处理业务逻辑，这里简单返回用户信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User created: Name - &quot;</span> + user.getName() + <span class="hljs-string">&quot;, Age - &quot;</span> + user.getAge();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>@RequestParam</code>用于接收 GET 请求参数，<code>@RequestBody</code>用于接收 POST 请求中 JSON 格式的参数。不同的后端框架和语言，接收参数的方式会有所不同，但基本原理类似。</p></li></ul></li><li><p><strong>五种参数传递（过一遍了解一下就行，开发中基本上用不到）P50</strong></p></li><li><p><strong>json数据，这个需要好好看，了解一下json格式规则  P51</strong></p><ol><li><strong>数据以键值对形式出现</strong>：在 JSON 中，数据由键值对组成，键和值之间使用英文冒号 <code>:</code> 分隔。例如，<code>&quot;name&quot;: &quot;John&quot;</code>，其中 <code>&quot;name&quot;</code> 是键，<code>&quot;John&quot;</code> 是值。键必须是字符串，并且使用英文双引号包裹；值可以是字符串、数字、布尔值、数组、对象或 <code>null</code>。</li><li><strong>使用英文大括号表示对象</strong>：一个 JSON 对象是一个无序的键值对集合，整体用英文大括号 <code>&#123;&#125;</code> 包围。例如：</li></ol><p>json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Alice&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isStudent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在这个对象中，包含了 <code>&quot;name&quot;</code>、<code>&quot;age&quot;</code> 和 <code>&quot;isStudent&quot;</code> 三个键值对。</p><ol start="3"><li><strong>使用英文方括号表示数组</strong>：JSON 数组是值的有序集合，用英文方括号 <code>[]</code> 包围。数组中的值可以是任意合法的 JSON 数据类型，包括字符串、数字、布尔值、数组、对象或 <code>null</code>。例如：</li></ol><p>json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;apple&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;banana&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;New York&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><ol><li><strong>字符串使用英文双引号包裹</strong>：如果值是字符串，必须使用英文双引号包裹。例如：<code>&quot;hello world&quot;</code>、<code>&quot;这是一个测试字符串&quot;</code>。</li><li><strong>数字类型</strong>：JSON 中的数字可以是整数或浮点数，不需要使用引号包裹。例如：<code>10</code>、<code>3.14</code>。</li><li><strong>布尔值</strong>：JSON 支持两个布尔值，分别是 <code>true</code> 和 <code>false</code>，不需要使用引号包裹。</li><li><strong><code>null</code> 值</strong>：JSON 中存在一个特殊的 <code>null</code> 值，表示空值或不存在的值，同样不需要使用引号包裹。</li><li><strong>数据项之间用英文逗号分隔</strong>：在对象中，多个键值对之间以及在数组中，多个值之间都使用英文逗号 <code>,</code> 分隔。例如：</li></ol><p>json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;key1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;key2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;key3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol><li><strong>大小写敏感</strong>：JSON 是大小写敏感的，例如 <code>&quot;Name&quot;</code> 和 <code>&quot;name&quot;</code> 被视为不同的键。</li></ol><p>严格遵循这些规则，可以确保 JSON 数据的正确解析和使用，使其在不同的编程语言和系统之间能够可靠地进行数据交换。</p></li><li><p><strong>响应数据 P53</strong></p></li><li><p><strong>RESTful风格（重点） P54-P58</strong></p><ul><li><p><strong>什么是restful风格？总结一下url格式</strong></p></li><li><p><strong>restful有几种行为操作（get、post、delete、put、delete），分别对应了对资源哪种操作？</strong></p></li><li><p><strong>思考一下，如何将所有的http请求抽象成对资源的增删改查操作？如何将对资源的操作抽象成restful形式</strong></p><ol><li>RESTful 风格<br>RESTful（Representational State Transfer）是一种软件架构风格，用于构建 Web 服务。它强调使用标准的 HTTP 方法（如 GET、POST、PUT、DELETE 等）来操作资源，并且资源通过 URL 进行唯一标识。RESTful 风格的 Web 服务具有轻量级、易于理解和扩展等优点，使得不同的系统之间能够更方便地进行交互。</li><li>URL 格式<ul><li><strong>资源导向</strong>：URL 应该指向资源，而不是具体的操作。</li><li><strong>名词复数形式</strong>：通常使用名词的复数形式来表示资源集合，如 <code>products</code>、<code>orders</code> 等，这样更符合 RESTful 风格中对资源的抽象。</li><li><strong>分层结构</strong>：可以使用分层的 URL 结构来表示资源之间的关系。</li><li><strong>避免动词</strong>：URL 中尽量避免使用动词，而是通过 HTTP 方法来表示对资源的操作。</li><li><strong>使用查询参数</strong>：当需要对资源进行过滤、排序等操作时，可以使用查询参数。</li></ul></li><li>RESTful 中几种行为操作及其对应的资源操作<ul><li><strong>GET</strong>：用于获取资源。可以获取单个资源，也可以获取资源集合，对应于资源的 “查” 操作。</li><li><strong>POST</strong>：用于创建新资源。通常将新资源的数据放在请求体中发送到服务器，例如 <code>POST https://example.com/api/users</code> 并在请求体中包含新用户的信息，服务器会根据这些信息创建一个新的用户资源，对应于资源的 “增” 操作。</li><li><strong>PUT</strong>：用于更新资源。一般用于更新整个资源，将完整的资源数据放在请求体中发送到服务器。例如 <code>PUT https://example.com/api/users/1</code> 并在请求体中包含更新后的用户信息，服务器会用新的信息替换原来 ID 为 1 的用户信息，对应于资源的 “改” 操作。</li><li><strong>DELETE</strong>：用于删除资源。</li></ul></li><li>将 HTTP 请求抽象成对资源的增删改查操作以及抽象成 RESTful 形式的方法<ul><li>将 HTTP 请求抽象成增删改查操作<ul><li>首先确定要操作的资源是什么，例如用户、产品、订单等。</li><li>根据操作的意图选择合适的 HTTP 方法。如果是获取资源，使用 GET；如果是创建新资源，使用 POST；如果是更新资源，使用 PUT 或 PATCH（部分更新）；如果是删除资源，使用 DELETE。</li><li>将资源的唯一标识（如 ID）包含在 URL 中，以便明确操作的是哪个具体资源。</li></ul></li><li>将对资源的操作抽象成 RESTful 形式<ul><li>按照资源导向的原则设计 URL，确保 URL 能够清晰地表示资源及其层次关系。</li><li>使用标准的 HTTP 方法来表示操作，避免在 URL 中使用自定义的动词。</li><li>对于复杂的操作，可以通过查询参数来实现。</li><li>响应数据也应该遵循 RESTful 风格，例如返回创建的资源的完整信息（POST 操作后），或者返回状态码来表示操作的结果（如 200 表示成功，404 表示资源未找到等）。</li></ul></li></ul></li></ol><p>通过以上方式，可以将 HTTP 请求和对资源的操作有效地抽象成 RESTful 风格，构建出易于理解和维护的 Web 服务。</p></li></ul></li></ul><p><em><strong>*练习*</strong></em></p><p>​      <strong>P62-P70（根据自己实际需要练习，建议跟着视频，也可以自己练习）</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作业3</title>
    <link href="/blog/2025/01/18/%E4%BD%9C%E4%B8%9A3/"/>
    <url>/blog/2025/01/18/%E4%BD%9C%E4%B8%9A3/</url>
    
    <content type="html"><![CDATA[<h3 id="容器？什么是容器？核心方法有哪些？"><a href="#容器？什么是容器？核心方法有哪些？" class="headerlink" title="容器？什么是容器？核心方法有哪些？"></a>容器？什么是容器？核心方法有哪些？</h3><p><strong>一、容器</strong></p><ul><li>容器的定义<ul><li>在软件开发中，容器是一种用于管理对象创建、生命周期和依赖关系的机制。它可以自动完成对象的实例化、配置和组装，将对象的创建和管理从代码中分离出来，使开发人员可以更专注于业务逻辑。常见的容器有 Spring 容器等。</li><li>容器通常会根据预先设定的配置信息（如配置文件、注解等）来创建和管理对象，并且可以在对象之间建立依赖关系，从而提高代码的可维护性和可扩展性。</li></ul></li><li>核心方法（以 Spring 容器为例）<ul><li><code>getBean(String name)</code>：根据指定的名称从容器中获取一个已创建的 Bean 实例。通过该方法可以从容器中检索出已经被容器管理的对象，例如<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); MyBean myBean = (MyBean) context.getBean(&quot;myBean&quot;);</code></li><li><code>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code>：将一个新的 Bean 定义注册到容器中。可以使用该方法来动态地添加新的 Bean 信息，例如在自定义的配置类中添加自定义的 Bean 信息。</li><li><code>refresh()</code>：刷新容器的状态，通常用于重新加载配置信息，对容器进行重新初始化和更新。例如，当修改了某些配置文件或者添加了新的 Bean 配置时，可以调用该方法使容器重新读取并更新其内部的 Bean 信息。</li></ul></li></ul><h3 id="注解-P20-P27"><a href="#注解-P20-P27" class="headerlink" title="注解 P20-P27"></a>注解 P20-P27</h3><p><strong>二、注解</strong></p><ul><li>如何使用注解定义 bean<ul><li>在 Java 中，使用 Spring 框架时，可以使用<code>@Component</code>注解及其衍生注解（如<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>）来定义一个 Bean。将这些注解添加到类的声明上，Spring 容器会自动扫描并将这些类作为 Bean 进行管理。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>上述代码使用<code>@Service</code>注解将<code>MyService</code>类标记为一个服务类，Spring 容器会自动将其创建为一个 Bean，并将其生命周期纳入容器的管理范围。</p><h3 id="有哪些常用注解"><a href="#有哪些常用注解" class="headerlink" title="有哪些常用注解"></a>有哪些常用注解</h3></li><li><p>常用注解</p><ul><li><code>@Component</code>：通用的组件注解，用于将类标记为 Spring 容器管理的组件。</li><li><code>@Service</code>：通常用于标记业务逻辑层的类。</li><li><code>@Controller</code>：用于标记控制器类，主要处理 HTTP 请求和响应。</li><li><code>@Repository</code>：通常用于标记数据访问层的类，与数据库操作相关。</li><li><code>@Autowired</code>：用于自动装配依赖，可以将其他 Bean 自动注入到使用该注解的属性、构造函数或方法中。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>@Autowired</code>注解将<code>MyRepository</code>类型的 Bean 自动注入到<code>myRepository</code>属性中，无需手动创建<code>MyRepository</code>的实例。</li><li><code>@Value</code>：用于注入外部化配置的值，如从配置文件中读取的值。例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;my.property.value&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String propertyValue;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>@Value</code>注解将配置文件中<code>my.property.value</code>的值注入到<code>propertyValue</code>属性中。</li><li><code>@Qualifier</code>：当有多个同类型的 Bean 时，可与<code>@Autowired</code>一起使用，指定具体要注入的 Bean。例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;specificMyRepository&quot;)</span><br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这里<code>@Qualifier(&quot;specificMyRepository&quot;)</code>用于指定要注入名为<code>specificMyRepository</code>的<code>MyRepository</code>类型的 Bean。</p><h3 id="注解定义的Bean生命周期和作用范围是什么？"><a href="#注解定义的Bean生命周期和作用范围是什么？" class="headerlink" title="注解定义的Bean生命周期和作用范围是什么？"></a>注解定义的Bean生命周期和作用范围是什么？</h3></li><li><p>注解定义的 Bean 生命周期和作用范围</p><ul><li>生命周期<ul><li><code>@PostConstruct</code>：在 Bean 的构造函数执行后，执行标记该注解的方法，可用于进行一些初始化操作。例如：</li></ul></li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化操作</span><br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>init</code>方法会在<code>MyService</code>的构造函数执行后自动调用，可用于初始化资源、建立连接等操作。</li><li><code>@PreDestroy</code>：在 Bean 被销毁前，执行标记该注解的方法，可用于进行一些资源释放操作。例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.PreDestroy;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 资源释放操作</span><br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>destroy</code>方法会在<code>MyService</code>的 Bean 被销毁前自动调用，用于释放资源，如关闭数据库连接等。</li><li>作用范围<ul><li><code>@Scope</code>：可以用来指定 Bean 的作用范围，常见的有<code>singleton</code>（单例，整个容器中只有一个实例）、<code>prototype</code>（每次请求都会创建一个新的实例）、<code>request</code>（在一个 HTTP 请求内是一个实例）、<code>session</code>（在一个 HTTP 会话内是一个实例）等。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Scope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>上述代码中，<code>@Scope(&quot;prototype&quot;)</code>将<code>MyService</code>的 Bean 设置为原型模式，每次请求都会创建一个新的实例。</p><h3 id="如何使用注解进行依赖注入？常用方法有哪些？"><a href="#如何使用注解进行依赖注入？常用方法有哪些？" class="headerlink" title="如何使用注解进行依赖注入？常用方法有哪些？"></a>如何使用注解进行依赖注入？常用方法有哪些？</h3></li><li><p>如何使用注解进行依赖注入</p><ul><li>如前面提到的<code>@Autowired</code>注解，可以用于属性、构造函数和方法上。</li><li>在构造函数上使用：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(MyRepository myRepository)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myRepository = myRepository;<br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，通过在构造函数上使用<code>@Autowired</code>注解，将<code>MyRepository</code>的 Bean 注入到<code>MyService</code>的构造函数中，保证<code>MyService</code>在创建时能获得所需的依赖。</li><li>在方法上使用：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMyRepository</span><span class="hljs-params">(MyRepository myRepository)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myRepository = myRepository;<br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这里<code>@Autowired</code>注解将<code>MyRepository</code>的 Bean 注入到<code>setMyRepository</code>方法中，从而为<code>myRepository</code>属性赋值。</p></li><li><p>常用方法：</p><ul><li>主要就是上述的构造函数注入、属性注入和方法注入，根据不同的场景和开发习惯选择使用。</li></ul><h3 id="如何用注解管理第三方bean？"><a href="#如何用注解管理第三方bean？" class="headerlink" title="如何用注解管理第三方bean？"></a>如何用注解管理第三方bean？</h3></li><li><p>如何用注解管理第三方 bean</p><ul><li>可以使用<code>@Configuration</code>和<code>@Bean</code>注解来管理第三方 Bean。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> com.thirdparty.MyThirdPartyClass;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThirdPartyConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyThirdPartyClass <span class="hljs-title function_">myThirdPartyBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThirdPartyClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>@Configuration</code>注解表明这是一个配置类，<code>@Bean</code>注解将<code>myThirdPartyBean</code>方法的返回值作为一个 Bean 注册到 Spring 容器中，这样就可以管理第三方类<code>MyThirdPartyClass</code>的实例。</li></ul><h3 id="AOP-P29-P39-什么是AOP？-使用AOP有哪些好处？-思考一下哪些场景可以用AOP？-如何定义一个切面？"><a href="#AOP-P29-P39-什么是AOP？-使用AOP有哪些好处？-思考一下哪些场景可以用AOP？-如何定义一个切面？" class="headerlink" title="AOP  P29-P39 什么是AOP？ 使用AOP有哪些好处？ 思考一下哪些场景可以用AOP？ 如何定义一个切面？"></a>AOP  P29-P39 什么是AOP？ 使用AOP有哪些好处？ 思考一下哪些场景可以用AOP？ 如何定义一个切面？</h3><p><strong>三、AOP</strong></p><ul><li>什么是 AOP<ul><li>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它允许开发人员将横切关注点（如日志记录、事务管理、安全检查等）从业务逻辑中分离出来，通过定义切面，将这些横切关注点统一管理。它可以在不修改业务逻辑代码的情况下，在程序的多个地方添加这些额外的功能。</li></ul></li><li>使用 AOP 的好处<ul><li>提高代码的可维护性：将横切关注点从业务逻辑中分离，使业务逻辑更清晰，易于维护和修改。</li><li>代码复用：将通用功能提取为切面，可在多个地方复用，避免代码重复。</li><li>更好的解耦：业务逻辑和横切功能相互独立，降低了它们之间的耦合度。</li></ul></li><li>哪些场景可以用 AOP<ul><li>日志记录：在方法调用前后记录日志，方便追踪和调试。</li><li>事务管理：在方法执行前后进行事务的开启、提交或回滚操作。</li><li>性能监控：统计方法的执行时间，进行性能分析。</li><li>安全检查：在方法调用前检查用户的权限等。</li></ul></li><li>如何定义一个切面<ul><li>使用<code>@Aspect</code>注解定义一个切面类，然后使用<code>@Before</code>、<code>@After</code>、<code>@Around</code>等注解定义切面的具体通知。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before advice&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>@Aspect</code>注解表示这是一个切面类，<code>@Before</code>注解表示在<code>com.example.service.MyService</code>类中的所有方法执行前执行<code>beforeAdvice</code>方法，可用于在方法执行前添加日志记录、权限检查等操作。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作业2</title>
    <link href="/blog/2025/01/17/%E4%BD%9C%E4%B8%9A2/"/>
    <url>/blog/2025/01/17/%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<p><em><strong>Spring概念</strong></em></p><ol><li><p>Spring引入带来了哪些好处？</p></li><li><p>什么是AOP？</p></li><li><p>什么是IOC？</p></li><li><p>什么是Bean？</p><p><strong>Spring框架的引入为企业级应用开发带来了诸多好处，主要包括简化开发过程、提高代码可维护性和可扩展性、降低组件之间的耦合度等</strong>。</p><p>AOP（面向切面编程）</p><ol><li><ul><li>AOP是一种编程范式，它允许开发者将横切关注点（如日志记录、事务管理、安全检查等）从业务逻辑中分离出来，并以声明式的方式集中管理这些关注点。</li><li>通过AOP，开发者可以编写“切面”，这些切面在运行时会被织入到目标对象的连接点（Join Point）上，比如方法执行前后、异常抛出时等。</li></ul></li><li>IOC（控制反转）<ul><li>IOC是一种设计思想，它将对象的创建和依赖关系管理的责任从应用程序代码转移到了一个专门的容器（即Spring容器）。</li><li>在传统的开发模式下，对象通常主动创建并管理它们所依赖的对象；而在IOC下，对象不再自行管理这些依赖，而是由容器负责创建对象实例，并通过依赖注入（Dependency Injection, DI）的方式将所需的依赖传递给对象。</li></ul></li><li>Bean<ul><li>在Spring框架中，<strong>Bean是构成应用程序核心的Java对象</strong>。这些对象由Spring IOC容器初始化、装配和管理。</li><li>Bean通过容器中配置的元数据创建，例如在XML文件中使用<code>&lt;bean&gt;</code>标签定义。Spring框架定义的bean都是单例bean，这意味着每个bean定义在容器中只有一个实例。</li></ul></li></ol></li></ol><p><em><strong>Bean</strong></em></p><ol><li><p>Bean是如何创建的？实例化bean的三种方式是什么？</p></li><li><p>普通对象怎么才能变成bean？</p></li><li><p>描述一下Bean生命周期</p><h4 id="Bean的创建及实例化方式"><a href="#Bean的创建及实例化方式" class="headerlink" title="Bean的创建及实例化方式"></a>Bean的创建及实例化方式</h4><ol><li><strong>Bean的创建</strong>：在Spring框架中，Bean的创建主要是由IOC容器负责的。当配置好一个Bean的定义后（例如通过XML配置文件或注解），IOC容器会根据这些定义来创建Bean的实例。</li><li>实例化Bean的三种方式<ul><li><strong>构造器实例化</strong>：这是最常用的方式，通过调用Bean的构造方法来创建实例。Spring容器在读取Bean的定义后，会根据定义的构造器参数来调用相应的构造方法。</li><li><strong>静态工厂方法实例化</strong>：通过一个静态工厂方法来创建Bean实例。在配置中指定工厂类的静态方法，Spring容器会调用该方法来获取Bean实例。</li><li><strong>实例工厂方法实例化</strong>：与静态工厂方法类似，但使用的是实例方法。需要先创建一个工厂Bean的实例，然后通过该实例调用工厂方法来获取目标Bean的实例。</li></ul></li></ol><h4 id="普通对象变成Bean的方法"><a href="#普通对象变成Bean的方法" class="headerlink" title="普通对象变成Bean的方法"></a>普通对象变成Bean的方法</h4><p>要将一个普通对象转变为Spring框架中的Bean，主要有以下步骤：</p><ol><li><strong>定义Bean</strong>：首先需要在Spring的配置文件中定义这个对象作为Bean，或者使用注解来标记这个类为Spring管理的Bean。</li><li><strong>配置依赖注入</strong>：在定义Bean时，可以配置它的依赖关系，Spring容器会在创建Bean实例时自动注入这些依赖。</li><li><strong>交由IOC容器管理</strong>：将对象的创建和管理交给Spring的IOC容器。容器会根据配置创建Bean实例，并管理其生命周期。</li></ol><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><ol><li><strong>实例化（Instantiation）</strong>：Spring容器根据Bean的定义创建Bean的实例。</li><li><strong>依赖注入（Dependency Injection）</strong>：容器将Bean所依赖的其他对象注入到Bean中。</li><li>初始化（Initialization）<ul><li>如果Bean实现了<code>InitializingBean</code>接口，会调用<code>afterPropertiesSet()</code>方法。</li><li>如果配置了<code>init-method</code>属性，会调用指定的初始化方法。</li></ul></li><li><strong>使用（Usage）</strong>：Bean实例现在可以被应用程序使用了，容器会维护一个Bean的实例池，按需提供实例。</li><li>销毁（Destruction）<ul><li>如果Bean实现了<code>DisposableBean</code>接口，会调用<code>destroy()</code>方法。</li><li>如果配置了<code>destroy-method</code>属性，会调用指定的销毁方法。</li></ul></li></ol><p>这个生命周期允许我们在Bean创建前后执行自定义的逻辑，比如资源初始化和清理工作。</p></li></ol><p><em><strong>依赖注入</strong></em></p><ol><li><p>setter注入</p></li><li><p>构造器注入</p></li><li><p>自动注入</p></li><li><p>集合注入</p><ol><li><em><strong>setter注入</strong></em>：这是最常用的依赖注入方式。通过在Java Bean中定义set方法，Spring容器在创建对象时，会调用这些set方法来注入依赖。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">java    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>        <span class="hljs-keyword">private</span> MyDependency dependency;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDependency</span><span class="hljs-params">(MyDependency dependency)</span> &#123;<br>            <span class="hljs-type">this</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> dependency;<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><ol><li><em><strong>构造器注入</strong></em>：这种方式是通过构造方法来注入依赖。这种方式可以确保对象在创建时就具有所有必要的依赖，并且可以使得依赖关系更加明确。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">java    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>        <span class="hljs-keyword">private</span> MyDependency dependency;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(MyDependency dependency)</span> &#123;<br>            <span class="hljs-type">this</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> dependency;<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><ol><li><em><strong>自动注入</strong></em>：Spring容器可以自动装配bean之间的依赖关系。这可以通过在配置文件中设置<code>autowire</code>属性来实现，或者在注解中使用<code>@Autowired</code>。例如：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myClass&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyClass&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>/&gt;</span><br>    <br></code></pre></td></tr></table></figure><ol><li><em><strong>集合注入</strong></em>：当需要注入集合类型（如List、Set、Map等）时，可以使用特定的XML标签来配置。例如：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myClass&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyClass&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>item1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>item2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作业1</title>
    <link href="/blog/2025/01/16/%E4%BD%9C%E4%B8%9A1/"/>
    <url>/blog/2025/01/16/%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<ol><li><h3 id="数据库数据类型，并指出这些类型对应Java里面的哪些数据类型"><a href="#数据库数据类型，并指出这些类型对应Java里面的哪些数据类型" class="headerlink" title="数据库数据类型，并指出这些类型对应Java里面的哪些数据类型"></a>数据库数据类型，并指出这些类型对应Java里面的哪些数据类型</h3><ol><li>整数类型<ul><li><strong>数据库</strong>：在 MySQL 中有 <code>INT</code>（4 字节）、<code>BIGINT</code>（8 字节）等；</li><li><strong>Java</strong>：<code>INT</code> 类型对应 Java 中的 <code>int</code> 类型；<code>BIGINT</code> 类型对应 Java 中的 <code>long</code> 类型；<code>SMALLINT</code> 类型对应 Java 中的 <code>short</code> 类型；TINYINT<code>类型对应 Java 中的</code>byte<code> 类型；</code></li></ul></li><li>浮点数和小数类型<ul><li><strong>数据库</strong>：MySQL 中有 <code>FLOAT</code>（单精度浮点数）、<code>DOUBLE</code>（双精度浮点数）、<code>DECIMAL</code>等。</li><li><strong>Java</strong>：<code>FLOAT</code> 对应 Java 中的 <code>float</code> 类型；<code>DOUBLE</code> 对应 Java 中的 <code>double</code> 类型；</li></ul></li><li>字符和字符串类型<ul><li><strong>数据库</strong>：MySQL 中有 <code>CHAR</code>（定长）、<code>VARCHAR</code>（变长）等；</li><li><strong>Java</strong>：这些类型在 Java 中对应 <code>String</code> 类型；</li></ul></li><li>日期和时间类型<ul><li><strong>数据库</strong>：MySQL 中有 <code>DATE</code>（只存储日期，格式为 <code>YYYY-MM-DD</code>）、<code>TIME</code>（只存储时间，格式为 <code>HH:MM:SS</code>）、<code>DATETIME</code>（存储日期和时间，格式为 <code>YYYY-MM-DD HH:MM:SS</code>）等；</li></ul></li></ol></li><li><h3 id="InnoDB存储引擎的特点？"><a href="#InnoDB存储引擎的特点？" class="headerlink" title="InnoDB存储引擎的特点？"></a>InnoDB存储引擎的特点？</h3><ol><li><em><strong>事务支持</strong></em>：InnoDB是MySQL中第一个提供外键约束的存储引擎，支持ACID兼容的事务，包括提交、回滚和崩溃恢复功能。</li><li><em><strong>行级锁定</strong></em>：InnoDB使用行级锁定，而不是表级锁定，这提高了多用户并发操作的性能。</li><li><em><strong>MVCC</strong></em>：通过多版本并发控制（MVCC）实现高并发性，支持一致性非锁定读。</li><li><em><strong>存储结构</strong></em>：InnoDB表在磁盘上按照主键的顺序存放数据，支持聚集索引和非聚集索引。</li><li><em><strong>缓冲池</strong></em>：InnoDB使用缓冲池技术来缓存数据和索引，以提高读写性能。</li><li><em><strong>自适应哈希索引</strong></em>：InnoDB会自动为频繁访问的索引页创建哈希索引，以提高查询性能。</li><li><em><strong>Change Buffer</strong></em>：InnoDB使用Change Buffer来缓存对非聚集非唯一索引的修改，以减少IO操作。</li><li><em><strong>Doublewrite Buffer</strong></em>：InnoDB使用Doublewrite Buffer来确保数据写入的可靠性，防止数据丢失。</li><li><em><strong>日志缓冲</strong></em>：InnoDB使用日志缓冲区来缓存重做日志，以减少磁盘IO操作。</li></ol><p>InnoDB引擎的这些特点使其成为需要高可靠性、高并发性和高性能的应用场景的首选存储引擎。</p></li><li><h3 id="如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构"><a href="#如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构" class="headerlink" title="如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构"></a>如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构</h3><p><img src="/blog/images/1.png"></p></li><li><h3 id="熟悉数据库表的增删改查操作"><a href="#熟悉数据库表的增删改查操作" class="headerlink" title="熟悉数据库表的增删改查操作"></a>熟悉数据库表的增删改查操作</h3><ol><li><strong>增加（Insert）</strong><ul><li>使用<code>INSERT INTO</code>语句向表中添加新记录。可以指定所有列或部分列的值。</li><li>例如：<code>INSERT INTO table_name (column1, column2) VALUES (value1, value2);</code></li></ul></li><li><strong>删除（Delete）</strong><ul><li>使用<code>DELETE FROM</code>语句从表中删除记录。可以使用<code>WHERE</code>子句来指定删除的条件。</li><li>例如：<code>DELETE FROM table_name WHERE condition;</code></li></ul></li><li><strong>修改（Update）</strong><ul><li>使用<code>UPDATE</code>语句来修改表中已有的记录。同样需要使用<code>WHERE</code>子句来指定修改的条件。</li><li>例如：<code>UPDATE table_name SET column1 = new_value WHERE condition;</code></li></ul></li><li><strong>查询（Select）</strong><ul><li>使用<code>SELECT</code>语句来查询表中的数据。可以选择所有列或特定列，也可以使用各种条件来过滤结果。</li><li>例如：<code>SELECT column1, column2 FROM table_name WHERE condition;</code></li></ul></li></ol></li><li><h3 id="熟悉数据库运算符号"><a href="#熟悉数据库运算符号" class="headerlink" title="熟悉数据库运算符号"></a>熟悉数据库运算符号</h3><ol><li><em><strong>算术运算符</strong></em>：加（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）</li><li><strong>比较运算符</strong>：等于（&#x3D;）、大于（&gt;）、小于（&lt;）、大于等于（&gt;&#x3D;）、小于等于（&lt;&#x3D;）、不等于（!&#x3D;）</li><li><em><strong>逻辑运算符</strong></em>：逻辑非（！）、逻辑与（&amp;&amp;）、逻辑或（||）等</li><li><em><strong>位运算符</strong></em>：位与（&amp;）、位或（|）、位异或（^）、位取反（~）、位左移（&lt;&lt;）和位右移（&gt;&gt;）</li><li><em><strong>关系运算符</strong></em>：包括并（V）、差（^）等</li></ol></li><li><h3 id="常用函数的使用，sum，avg等"><a href="#常用函数的使用，sum，avg等" class="headerlink" title="常用函数的使用，sum，avg等"></a>常用函数的使用，sum，avg等</h3><h4 id="SUM函数"><a href="#SUM函数" class="headerlink" title="SUM函数"></a><strong>SUM函数</strong></h4><p>SUM函数用于计算某一单元格区域中数字之和。其语法为：SUM(number1, number2,…)，其中number1、number2等可以是数字、单元格引用或区域。</p><h4 id="AVG函数"><a href="#AVG函数" class="headerlink" title="AVG函数"></a><strong>AVG函数</strong></h4><p>AVG函数用于计算某一单元格区域中数字的平均值。其语法为：AVG(number1, number2,…)，其中number1、number2等可以是数字、单元格引用或区域。</p></li><li><h3 id="熟悉掌握和运用各种索引"><a href="#熟悉掌握和运用各种索引" class="headerlink" title="熟悉掌握和运用各种索引"></a>熟悉掌握和运用各种索引</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a><strong>索引类型</strong></h4><ol><li><em><strong>普通索引</strong></em>：最基础的索引类型，允许重复值和NULL值，适用于大多数查询场景。</li><li><em><strong>唯一索引</strong></em>：确保索引列中的值唯一，但允许有空值（NULL）。适用于需要确保数据唯一性但允许某些记录值缺失的场景。</li><li><em><strong>全文索引</strong></em>：用于对文本内容进行高效搜索，支持分词和模糊匹配。适用于搜索引擎和需要对大量文本数据进行搜索的场景。</li><li><em><strong>覆盖索引</strong></em>：查询中所需的所有列都包含在索引中，减少I&#x2F;O操作，提高查询效率。</li><li><em><strong>组合索引</strong></em>：由多个列的值组成，用于优化多列的组合查询。</li><li><em><strong>聚簇索引和非聚簇索引</strong></em>：聚簇索引定义了表中数据的物理存储方式，非聚簇索引独立于数据的物理存储。</li></ol><h4 id="索引的使用技巧"><a href="#索引的使用技巧" class="headerlink" title="索引的使用技巧"></a><strong>索引的使用技巧</strong></h4><ol><li><em><strong>避免全表扫描</strong></em>：在where及order by，group by涉及的列上建立索引。</li><li><em><strong>避免滥用索引</strong></em>：过多的索引会降低更新表的速度，并占用磁盘空间。</li><li><em><strong>避免使用!&#x3D;或&lt;&gt;操作符</strong></em>：否则将引擎放弃使用索引而进行全表扫描。</li><li><em><strong>避免在where子句中对字段进行null值判断</strong></em>：否则将导致引擎放弃使用索引而进行全表扫描。</li><li><em><strong>避免在where子句中使用or来连接条件</strong></em>：否则将导致引擎放弃使用索引而进行全表扫描。</li><li><em><strong>避免使用like通配符</strong></em>：当通配符位于字符串的开始位置（例如%keyword），MySQL可能无法利用索引进行快速查找。</li><li><em><strong>避免在索引列上使用内置函数</strong></em>：对索引列应用MySQL内置函数，会使得MySQL无法直接使用索引进行查找。</li><li><em><strong>避免在索引列上执行算术运算</strong></em>：在索引列上执行算术运算（如加、减、乘、除）会使得MySQL无法利用索引进行数据查找。</li></ol><h4 id="索引的应用场景"><a href="#索引的应用场景" class="headerlink" title="索引的应用场景"></a><strong>索引的应用场景</strong></h4><ol><li><em><strong>获取列表中特定位置的元素</strong></em>：通过索引快速获取列表中特定位置的元素。</li><li><em><strong>截取字符串的子串</strong></em>：使用字符串索引来截取子串。</li><li><em><strong>定位元组中的某个值</strong></em>：通过索引快速定位元组中的某个值。</li></ol></li><li><h3 id="数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group-by，having等"><a href="#数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group-by，having等" class="headerlink" title="数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group by，having等"></a>数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group by，having等</h3><h4 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h4><p>WHERE子句用于过滤记录，即从表中选择满足指定条件的行。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这将返回所有部门ID为10的员工记录。</p><h4 id="IN子句"><a href="#IN子句" class="headerlink" title="IN子句"></a>IN子句</h4><p>IN子句允许您在WHERE子句中指定多个可能的值。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>这将返回部门ID为10、20或30的所有员工记录。</p><h4 id="LIKE子句"><a href="#LIKE子句" class="headerlink" title="LIKE子句"></a>LIKE子句</h4><p>LIKE子句用于在WHERE子句中搜索列中的指定模式。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> first_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;J%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这将返回所有名字以“J”开头的员工记录。</p><h4 id="BETWEEN…AND…子句"><a href="#BETWEEN…AND…子句" class="headerlink" title="BETWEEN…AND…子句"></a>BETWEEN…AND…子句</h4><p>BETWEEN…AND…子句用于在WHERE子句中选择介于两个值之间的范围。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> salary <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">50000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">100000</span>;<br></code></pre></td></tr></table></figure><p>这将返回所有薪资在50000到100000之间的员工记录。</p><h4 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h4><p>GROUP BY子句用于将表中的记录按照一个或多个列进行分组。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT department_id, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num_employees <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br></code></pre></td></tr></table></figure><p>这将返回每个部门的员工数量。</p><h4 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h4><p>HAVING子句用于在GROUP BY子句之后过滤分组结果。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT department_id, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num_employees <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>这将返回员工数量大于5的部门。</p></li><li><h3 id="要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作"><a href="#要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作" class="headerlink" title="要熟悉掌握left join,inner join,right join,cross jion 这些连表操作"></a>要熟悉掌握left join,inner join,right join,cross jion 这些连表操作</h3><ol><li><strong>INNER JOIN</strong><ul><li>返回两个表中满足连接条件的记录。如果某个表中的行在另一个表中没有匹配行，则这些行不会出现在结果集中。</li><li>例如：<code>SELECT * FROM TableA INNER JOIN TableB ON TableA.Key = TableB.Key</code>。</li></ul></li><li><strong>LEFT JOIN</strong><ul><li>返回左表的所有记录，以及右表中与左表匹配的记录。如果右表中没有匹配的记录，则右表的部分显示为NULL。</li><li>例如：<code>SELECT * FROM TableA LEFT JOIN TableB ON TableA.Key = TableB.Key</code>。</li></ul></li><li><strong>RIGHT JOIN</strong><ul><li>返回右表的所有记录，以及左表中与右表匹配的记录。如果左表中没有匹配的记录，则左表的部分显示为NULL。</li><li>例如：<code>SELECT * FROM TableA RIGHT JOIN TableB ON TableA.Key = TableB.Key</code>。</li></ul></li><li><strong>CROSS JOIN</strong><ul><li>返回两个表的笛卡尔积，即第一个表中的每一行与第二个表中的每一行组合生成一个新的行。如果第一个表有m行，第二个表有n行，则结果有m*n行。</li><li>例如：<code>SELECT * FROM TableA CROSS JOIN TableB</code>。</li></ul></li></ol></li></ol><p>力扣题目：</p><ol><li><a href="https://leetcode.cn/problems/combine-two-tables/description/">175. 组合两个表 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/employees-earning-more-than-their-managers/">181. 超过经理收入的员工 - 力扣（LeetCode）</a></li></ol><p>进阶：</p><ol><li><h3 id="索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？"><a href="#索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？" class="headerlink" title="索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？"></a>索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？</h3><ol><li><strong>磁盘IO效率</strong>：B+树的所有数据都存储在叶子节点，这使得查询时需要的磁盘IO次数更少，因为通常只需要访问叶子节点即可获取数据。B树的非叶子节点也存储数据，导致查询可能需要访问更多的层级，增加了IO成本。</li><li><strong>范围查询效率</strong>：B+树的叶子节点是双向链表，非常适合进行范围查询，因为一旦定位到起始点，可以通过链表顺序访问后续的相关数据。B树则需要在每次范围查询时从根节点重新开始遍历。</li><li><strong>稳定性</strong>：B+树的结构更加稳定，因为它的非叶子节点只存储索引信息，不存储实际数据，这使得树的结构在插入和删除操作时更加稳定，减少了树的重组频率。</li></ol><p>索引下推是一种优化技术，它允许在索引遍历过程中对索引中的数据进行过滤，从而减少需要回表查询的数据量。例如，如果有一个联合索引（如name和age），并且查询条件是name like ‘张%’ and age &gt; 10，索引下推会在索引层面对满足name条件的记录进一步筛选age条件，而不是先将所有满足name条件的记录回表后再进行筛选。</p><p>回表是指在非主键索引（也称为二级索引）的查询中，当通过索引找到匹配的记录后，还需要根据索引中存储的主键值返回到主键索引去查询完整的行数据。这是因为二级索引的叶子节点只存储了索引列和主键值，而不包含所有列的数据。</p></li><li><h3 id="要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作，要知道怎么连接的，并用韦恩图画出来。"><a href="#要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作，要知道怎么连接的，并用韦恩图画出来。" class="headerlink" title="要熟悉掌握left join,inner join,right join,cross jion 这些连表操作，要知道怎么连接的，并用韦恩图画出来。"></a>要熟悉掌握left join,inner join,right join,cross jion 这些连表操作，要知道怎么连接的，并用韦恩图画出来。</h3><p><strong>INNER JOIN</strong></p><ul><li>只返回两个表中满足连接条件的行。</li><li>如果某行在其中一个表中没有匹配，则不会出现在结果集中。</li><li>韦恩图表示：只有两个集合交集的部分。</li></ul><p><strong>LEFT JOIN (LEFT OUTER JOIN)</strong></p><ul><li>返回左表中的所有行，即使在右表中没有匹配的行。</li><li>如果右表中没有匹配的行，则结果集中的右表列将为NULL。</li><li>韦恩图表示：左表全部加上两个集合交集的部分。</li></ul><h5 id="RIGHT-JOIN-RIGHT-OUTER-JOIN"><a href="#RIGHT-JOIN-RIGHT-OUTER-JOIN" class="headerlink" title="RIGHT JOIN (RIGHT OUTER JOIN)"></a>RIGHT JOIN (RIGHT OUTER JOIN)</h5><ul><li>返回右表中的所有行，即使在左表中没有匹配的行。</li><li>如果左表中没有匹配的行，则结果集中的左表列将为NULL。</li><li>韦恩图表示：右表全部加上两个集合交集的部分。</li></ul><p><strong>CROSS JOIN</strong></p><ul><li>返回两个表的笛卡尔积，即第一个表的每一行与第二个表的每一行组合。</li><li>不需要指定连接条件，但结果集可能非常大。</li><li>韦恩图表示：两个集合的全部区域。</li></ul></li></ol><p>为了更直观地理解这些连接操作，可以使用韦恩图来表示不同<code>JOIN</code>类型所涵盖的数据范围：</p><ul><li><strong>INNER JOIN</strong>：两个圆的重叠部分。</li><li><strong>LEFT JOIN</strong>：左圆及其与右圆重叠的部分。</li><li><strong>RIGHT JOIN</strong>：右圆及其与左圆重叠的部分。</li><li><strong>CROSS JOIN</strong>：两个圆的全部区域，包括重叠部分和非重叠部分。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog/2025/01/14/hello-world/"/>
    <url>/blog/2025/01/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
