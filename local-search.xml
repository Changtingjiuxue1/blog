<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/2025/01/18/%E4%BD%9C%E4%B8%9A3/"/>
    <url>/blog/2025/01/18/%E4%BD%9C%E4%B8%9A3/</url>
    
    <content type="html"><![CDATA[<h3 id="容器？什么是容器？核心方法有哪些？P19、P20"><a href="#容器？什么是容器？核心方法有哪些？P19、P20" class="headerlink" title="容器？什么是容器？核心方法有哪些？P19、P20"></a>容器？什么是容器？核心方法有哪些？P19、P20</h3><p><strong>一、容器</strong></p><ul><li>容器的定义<ul><li>在软件开发中，容器是一种用于管理对象创建、生命周期和依赖关系的机制。它可以自动完成对象的实例化、配置和组装，将对象的创建和管理从代码中分离出来，使开发人员可以更专注于业务逻辑。常见的容器有 Spring 容器等。</li><li>容器通常会根据预先设定的配置信息（如配置文件、注解等）来创建和管理对象，并且可以在对象之间建立依赖关系，从而提高代码的可维护性和可扩展性。</li></ul></li><li>核心方法（以 Spring 容器为例）<ul><li><code>getBean(String name)</code>：根据指定的名称从容器中获取一个已创建的 Bean 实例。通过该方法可以从容器中检索出已经被容器管理的对象，例如<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); MyBean myBean = (MyBean) context.getBean(&quot;myBean&quot;);</code></li><li><code>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code>：将一个新的 Bean 定义注册到容器中。可以使用该方法来动态地添加新的 Bean 信息，例如在自定义的配置类中添加自定义的 Bean 信息。</li><li><code>refresh()</code>：刷新容器的状态，通常用于重新加载配置信息，对容器进行重新初始化和更新。例如，当修改了某些配置文件或者添加了新的 Bean 配置时，可以调用该方法使容器重新读取并更新其内部的 Bean 信息。</li></ul></li></ul><h3 id="注解-P20-P27"><a href="#注解-P20-P27" class="headerlink" title="注解 P20-P27"></a>注解 P20-P27</h3><p><strong>二、注解</strong></p><ul><li>如何使用注解定义 bean<ul><li>在 Java 中，使用 Spring 框架时，可以使用<code>@Component</code>注解及其衍生注解（如<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>）来定义一个 Bean。将这些注解添加到类的声明上，Spring 容器会自动扫描并将这些类作为 Bean 进行管理。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>上述代码使用<code>@Service</code>注解将<code>MyService</code>类标记为一个服务类，Spring 容器会自动将其创建为一个 Bean，并将其生命周期纳入容器的管理范围。</p><h3 id="有哪些常用注解"><a href="#有哪些常用注解" class="headerlink" title="有哪些常用注解"></a>有哪些常用注解</h3></li><li><p>常用注解</p><ul><li><code>@Component</code>：通用的组件注解，用于将类标记为 Spring 容器管理的组件。</li><li><code>@Service</code>：通常用于标记业务逻辑层的类。</li><li><code>@Controller</code>：用于标记控制器类，主要处理 HTTP 请求和响应。</li><li><code>@Repository</code>：通常用于标记数据访问层的类，与数据库操作相关。</li><li><code>@Autowired</code>：用于自动装配依赖，可以将其他 Bean 自动注入到使用该注解的属性、构造函数或方法中。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>@Autowired</code>注解将<code>MyRepository</code>类型的 Bean 自动注入到<code>myRepository</code>属性中，无需手动创建<code>MyRepository</code>的实例。</li><li><code>@Value</code>：用于注入外部化配置的值，如从配置文件中读取的值。例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;my.property.value&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String propertyValue;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>@Value</code>注解将配置文件中<code>my.property.value</code>的值注入到<code>propertyValue</code>属性中。</li><li><code>@Qualifier</code>：当有多个同类型的 Bean 时，可与<code>@Autowired</code>一起使用，指定具体要注入的 Bean。例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;specificMyRepository&quot;)</span><br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这里<code>@Qualifier(&quot;specificMyRepository&quot;)</code>用于指定要注入名为<code>specificMyRepository</code>的<code>MyRepository</code>类型的 Bean。</p><h3 id="注解定义的Bean生命周期和作用范围是什么？"><a href="#注解定义的Bean生命周期和作用范围是什么？" class="headerlink" title="注解定义的Bean生命周期和作用范围是什么？"></a>注解定义的Bean生命周期和作用范围是什么？</h3></li><li><p>注解定义的 Bean 生命周期和作用范围</p><ul><li>生命周期<ul><li><code>@PostConstruct</code>：在 Bean 的构造函数执行后，执行标记该注解的方法，可用于进行一些初始化操作。例如：</li></ul></li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化操作</span><br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>init</code>方法会在<code>MyService</code>的构造函数执行后自动调用，可用于初始化资源、建立连接等操作。</li><li><code>@PreDestroy</code>：在 Bean 被销毁前，执行标记该注解的方法，可用于进行一些资源释放操作。例如：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.PreDestroy;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 资源释放操作</span><br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>destroy</code>方法会在<code>MyService</code>的 Bean 被销毁前自动调用，用于释放资源，如关闭数据库连接等。</li><li>作用范围<ul><li><code>@Scope</code>：可以用来指定 Bean 的作用范围，常见的有<code>singleton</code>（单例，整个容器中只有一个实例）、<code>prototype</code>（每次请求都会创建一个新的实例）、<code>request</code>（在一个 HTTP 请求内是一个实例）、<code>session</code>（在一个 HTTP 会话内是一个实例）等。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Scope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>上述代码中，<code>@Scope(&quot;prototype&quot;)</code>将<code>MyService</code>的 Bean 设置为原型模式，每次请求都会创建一个新的实例。</p><h3 id="如何使用注解进行依赖注入？常用方法有哪些？"><a href="#如何使用注解进行依赖注入？常用方法有哪些？" class="headerlink" title="如何使用注解进行依赖注入？常用方法有哪些？"></a>如何使用注解进行依赖注入？常用方法有哪些？</h3></li><li><p>如何使用注解进行依赖注入</p><ul><li>如前面提到的<code>@Autowired</code>注解，可以用于属性、构造函数和方法上。</li><li>在构造函数上使用：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(MyRepository myRepository)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myRepository = myRepository;<br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，通过在构造函数上使用<code>@Autowired</code>注解，将<code>MyRepository</code>的 Bean 注入到<code>MyService</code>的构造函数中，保证<code>MyService</code>在创建时能获得所需的依赖。</li><li>在方法上使用：</li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMyRepository</span><span class="hljs-params">(MyRepository myRepository)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myRepository = myRepository;<br>    &#125;<br>    <span class="hljs-comment">// 类的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这里<code>@Autowired</code>注解将<code>MyRepository</code>的 Bean 注入到<code>setMyRepository</code>方法中，从而为<code>myRepository</code>属性赋值。</p></li><li><p>常用方法：</p><ul><li>主要就是上述的构造函数注入、属性注入和方法注入，根据不同的场景和开发习惯选择使用。</li></ul><h3 id="如何用注解管理第三方bean？"><a href="#如何用注解管理第三方bean？" class="headerlink" title="如何用注解管理第三方bean？"></a>如何用注解管理第三方bean？</h3></li><li><p>如何用注解管理第三方 bean</p><ul><li>可以使用<code>@Configuration</code>和<code>@Bean</code>注解来管理第三方 Bean。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> com.thirdparty.MyThirdPartyClass;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThirdPartyConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyThirdPartyClass <span class="hljs-title function_">myThirdPartyBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThirdPartyClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>@Configuration</code>注解表明这是一个配置类，<code>@Bean</code>注解将<code>myThirdPartyBean</code>方法的返回值作为一个 Bean 注册到 Spring 容器中，这样就可以管理第三方类<code>MyThirdPartyClass</code>的实例。</li></ul><h3 id="AOP-P29-P39-什么是AOP？-使用AOP有哪些好处？-思考一下哪些场景可以用AOP？-如何定义一个切面？"><a href="#AOP-P29-P39-什么是AOP？-使用AOP有哪些好处？-思考一下哪些场景可以用AOP？-如何定义一个切面？" class="headerlink" title="AOP  P29-P39 什么是AOP？ 使用AOP有哪些好处？ 思考一下哪些场景可以用AOP？ 如何定义一个切面？"></a>AOP  P29-P39 什么是AOP？ 使用AOP有哪些好处？ 思考一下哪些场景可以用AOP？ 如何定义一个切面？</h3><p><strong>三、AOP</strong></p><ul><li>什么是 AOP<ul><li>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它允许开发人员将横切关注点（如日志记录、事务管理、安全检查等）从业务逻辑中分离出来，通过定义切面，将这些横切关注点统一管理。它可以在不修改业务逻辑代码的情况下，在程序的多个地方添加这些额外的功能。</li></ul></li><li>使用 AOP 的好处<ul><li>提高代码的可维护性：将横切关注点从业务逻辑中分离，使业务逻辑更清晰，易于维护和修改。</li><li>代码复用：将通用功能提取为切面，可在多个地方复用，避免代码重复。</li><li>更好的解耦：业务逻辑和横切功能相互独立，降低了它们之间的耦合度。</li></ul></li><li>哪些场景可以用 AOP<ul><li>日志记录：在方法调用前后记录日志，方便追踪和调试。</li><li>事务管理：在方法执行前后进行事务的开启、提交或回滚操作。</li><li>性能监控：统计方法的执行时间，进行性能分析。</li><li>安全检查：在方法调用前检查用户的权限等。</li></ul></li><li>如何定义一个切面<ul><li>使用<code>@Aspect</code>注解定义一个切面类，然后使用<code>@Before</code>、<code>@After</code>、<code>@Around</code>等注解定义切面的具体通知。例如：</li></ul></li></ul><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before advice&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码中，<code>@Aspect</code>注解表示这是一个切面类，<code>@Before</code>注解表示在<code>com.example.service.MyService</code>类中的所有方法执行前执行<code>beforeAdvice</code>方法，可用于在方法执行前添加日志记录、权限检查等操作。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作业2</title>
    <link href="/blog/2025/01/17/%E4%BD%9C%E4%B8%9A2/"/>
    <url>/blog/2025/01/17/%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<p><em><strong>Spring概念</strong></em></p><ol><li><p>Spring引入带来了哪些好处？</p></li><li><p>什么是AOP？</p></li><li><p>什么是IOC？</p></li><li><p>什么是Bean？</p><p><strong>Spring框架的引入为企业级应用开发带来了诸多好处，主要包括简化开发过程、提高代码可维护性和可扩展性、降低组件之间的耦合度等</strong>。</p><p>AOP（面向切面编程）</p><ol><li><ul><li>AOP是一种编程范式，它允许开发者将横切关注点（如日志记录、事务管理、安全检查等）从业务逻辑中分离出来，并以声明式的方式集中管理这些关注点。</li><li>通过AOP，开发者可以编写“切面”，这些切面在运行时会被织入到目标对象的连接点（Join Point）上，比如方法执行前后、异常抛出时等。</li></ul></li><li>IOC（控制反转）<ul><li>IOC是一种设计思想，它将对象的创建和依赖关系管理的责任从应用程序代码转移到了一个专门的容器（即Spring容器）。</li><li>在传统的开发模式下，对象通常主动创建并管理它们所依赖的对象；而在IOC下，对象不再自行管理这些依赖，而是由容器负责创建对象实例，并通过依赖注入（Dependency Injection, DI）的方式将所需的依赖传递给对象。</li></ul></li><li>Bean<ul><li>在Spring框架中，<strong>Bean是构成应用程序核心的Java对象</strong>。这些对象由Spring IOC容器初始化、装配和管理。</li><li>Bean通过容器中配置的元数据创建，例如在XML文件中使用<code>&lt;bean&gt;</code>标签定义。Spring框架定义的bean都是单例bean，这意味着每个bean定义在容器中只有一个实例。</li></ul></li></ol></li></ol><p><em><strong>Bean</strong></em></p><ol><li><p>Bean是如何创建的？实例化bean的三种方式是什么？</p></li><li><p>普通对象怎么才能变成bean？</p></li><li><p>描述一下Bean生命周期</p><h4 id="Bean的创建及实例化方式"><a href="#Bean的创建及实例化方式" class="headerlink" title="Bean的创建及实例化方式"></a>Bean的创建及实例化方式</h4><ol><li><strong>Bean的创建</strong>：在Spring框架中，Bean的创建主要是由IOC容器负责的。当配置好一个Bean的定义后（例如通过XML配置文件或注解），IOC容器会根据这些定义来创建Bean的实例。</li><li>实例化Bean的三种方式<ul><li><strong>构造器实例化</strong>：这是最常用的方式，通过调用Bean的构造方法来创建实例。Spring容器在读取Bean的定义后，会根据定义的构造器参数来调用相应的构造方法。</li><li><strong>静态工厂方法实例化</strong>：通过一个静态工厂方法来创建Bean实例。在配置中指定工厂类的静态方法，Spring容器会调用该方法来获取Bean实例。</li><li><strong>实例工厂方法实例化</strong>：与静态工厂方法类似，但使用的是实例方法。需要先创建一个工厂Bean的实例，然后通过该实例调用工厂方法来获取目标Bean的实例。</li></ul></li></ol><h4 id="普通对象变成Bean的方法"><a href="#普通对象变成Bean的方法" class="headerlink" title="普通对象变成Bean的方法"></a>普通对象变成Bean的方法</h4><p>要将一个普通对象转变为Spring框架中的Bean，主要有以下步骤：</p><ol><li><strong>定义Bean</strong>：首先需要在Spring的配置文件中定义这个对象作为Bean，或者使用注解来标记这个类为Spring管理的Bean。</li><li><strong>配置依赖注入</strong>：在定义Bean时，可以配置它的依赖关系，Spring容器会在创建Bean实例时自动注入这些依赖。</li><li><strong>交由IOC容器管理</strong>：将对象的创建和管理交给Spring的IOC容器。容器会根据配置创建Bean实例，并管理其生命周期。</li></ol><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><ol><li><strong>实例化（Instantiation）</strong>：Spring容器根据Bean的定义创建Bean的实例。</li><li><strong>依赖注入（Dependency Injection）</strong>：容器将Bean所依赖的其他对象注入到Bean中。</li><li>初始化（Initialization）<ul><li>如果Bean实现了<code>InitializingBean</code>接口，会调用<code>afterPropertiesSet()</code>方法。</li><li>如果配置了<code>init-method</code>属性，会调用指定的初始化方法。</li></ul></li><li><strong>使用（Usage）</strong>：Bean实例现在可以被应用程序使用了，容器会维护一个Bean的实例池，按需提供实例。</li><li>销毁（Destruction）<ul><li>如果Bean实现了<code>DisposableBean</code>接口，会调用<code>destroy()</code>方法。</li><li>如果配置了<code>destroy-method</code>属性，会调用指定的销毁方法。</li></ul></li></ol><p>这个生命周期允许我们在Bean创建前后执行自定义的逻辑，比如资源初始化和清理工作。</p></li></ol><p><em><strong>依赖注入</strong></em></p><ol><li><p>setter注入</p></li><li><p>构造器注入</p></li><li><p>自动注入</p></li><li><p>集合注入</p><ol><li><em><strong>setter注入</strong></em>：这是最常用的依赖注入方式。通过在Java Bean中定义set方法，Spring容器在创建对象时，会调用这些set方法来注入依赖。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">java    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>        <span class="hljs-keyword">private</span> MyDependency dependency;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDependency</span><span class="hljs-params">(MyDependency dependency)</span> &#123;<br>            <span class="hljs-type">this</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> dependency;<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><ol><li><em><strong>构造器注入</strong></em>：这种方式是通过构造方法来注入依赖。这种方式可以确保对象在创建时就具有所有必要的依赖，并且可以使得依赖关系更加明确。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">java    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>        <span class="hljs-keyword">private</span> MyDependency dependency;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(MyDependency dependency)</span> &#123;<br>            <span class="hljs-type">this</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> dependency;<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><ol><li><em><strong>自动注入</strong></em>：Spring容器可以自动装配bean之间的依赖关系。这可以通过在配置文件中设置<code>autowire</code>属性来实现，或者在注解中使用<code>@Autowired</code>。例如：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myClass&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyClass&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>/&gt;</span><br>    <br></code></pre></td></tr></table></figure><ol><li><em><strong>集合注入</strong></em>：当需要注入集合类型（如List、Set、Map等）时，可以使用特定的XML标签来配置。例如：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myClass&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyClass&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>item1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>item2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作业1</title>
    <link href="/blog/2025/01/16/%E4%BD%9C%E4%B8%9A1/"/>
    <url>/blog/2025/01/16/%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<ol><li><h3 id="数据库数据类型，并指出这些类型对应Java里面的哪些数据类型"><a href="#数据库数据类型，并指出这些类型对应Java里面的哪些数据类型" class="headerlink" title="数据库数据类型，并指出这些类型对应Java里面的哪些数据类型"></a>数据库数据类型，并指出这些类型对应Java里面的哪些数据类型</h3><ol><li>整数类型<ul><li><strong>数据库</strong>：在 MySQL 中有 <code>INT</code>（4 字节）、<code>BIGINT</code>（8 字节）等；</li><li><strong>Java</strong>：<code>INT</code> 类型对应 Java 中的 <code>int</code> 类型；<code>BIGINT</code> 类型对应 Java 中的 <code>long</code> 类型；<code>SMALLINT</code> 类型对应 Java 中的 <code>short</code> 类型；TINYINT<code>类型对应 Java 中的</code>byte<code> 类型；</code></li></ul></li><li>浮点数和小数类型<ul><li><strong>数据库</strong>：MySQL 中有 <code>FLOAT</code>（单精度浮点数）、<code>DOUBLE</code>（双精度浮点数）、<code>DECIMAL</code>等。</li><li><strong>Java</strong>：<code>FLOAT</code> 对应 Java 中的 <code>float</code> 类型；<code>DOUBLE</code> 对应 Java 中的 <code>double</code> 类型；</li></ul></li><li>字符和字符串类型<ul><li><strong>数据库</strong>：MySQL 中有 <code>CHAR</code>（定长）、<code>VARCHAR</code>（变长）等；</li><li><strong>Java</strong>：这些类型在 Java 中对应 <code>String</code> 类型；</li></ul></li><li>日期和时间类型<ul><li><strong>数据库</strong>：MySQL 中有 <code>DATE</code>（只存储日期，格式为 <code>YYYY-MM-DD</code>）、<code>TIME</code>（只存储时间，格式为 <code>HH:MM:SS</code>）、<code>DATETIME</code>（存储日期和时间，格式为 <code>YYYY-MM-DD HH:MM:SS</code>）等；</li></ul></li></ol></li><li><h3 id="InnoDB存储引擎的特点？"><a href="#InnoDB存储引擎的特点？" class="headerlink" title="InnoDB存储引擎的特点？"></a>InnoDB存储引擎的特点？</h3><ol><li><em><strong>事务支持</strong></em>：InnoDB是MySQL中第一个提供外键约束的存储引擎，支持ACID兼容的事务，包括提交、回滚和崩溃恢复功能。</li><li><em><strong>行级锁定</strong></em>：InnoDB使用行级锁定，而不是表级锁定，这提高了多用户并发操作的性能。</li><li><em><strong>MVCC</strong></em>：通过多版本并发控制（MVCC）实现高并发性，支持一致性非锁定读。</li><li><em><strong>存储结构</strong></em>：InnoDB表在磁盘上按照主键的顺序存放数据，支持聚集索引和非聚集索引。</li><li><em><strong>缓冲池</strong></em>：InnoDB使用缓冲池技术来缓存数据和索引，以提高读写性能。</li><li><em><strong>自适应哈希索引</strong></em>：InnoDB会自动为频繁访问的索引页创建哈希索引，以提高查询性能。</li><li><em><strong>Change Buffer</strong></em>：InnoDB使用Change Buffer来缓存对非聚集非唯一索引的修改，以减少IO操作。</li><li><em><strong>Doublewrite Buffer</strong></em>：InnoDB使用Doublewrite Buffer来确保数据写入的可靠性，防止数据丢失。</li><li><em><strong>日志缓冲</strong></em>：InnoDB使用日志缓冲区来缓存重做日志，以减少磁盘IO操作。</li></ol><p>InnoDB引擎的这些特点使其成为需要高可靠性、高并发性和高性能的应用场景的首选存储引擎。</p></li><li><h3 id="如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构"><a href="#如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构" class="headerlink" title="如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构"></a>如何使用SQL语句创建数据库、创建表、删除数据库、删除表、修改表结构</h3><p><img src="/blog/images/1.png"></p></li><li><h3 id="熟悉数据库表的增删改查操作"><a href="#熟悉数据库表的增删改查操作" class="headerlink" title="熟悉数据库表的增删改查操作"></a>熟悉数据库表的增删改查操作</h3><ol><li><strong>增加（Insert）</strong><ul><li>使用<code>INSERT INTO</code>语句向表中添加新记录。可以指定所有列或部分列的值。</li><li>例如：<code>INSERT INTO table_name (column1, column2) VALUES (value1, value2);</code></li></ul></li><li><strong>删除（Delete）</strong><ul><li>使用<code>DELETE FROM</code>语句从表中删除记录。可以使用<code>WHERE</code>子句来指定删除的条件。</li><li>例如：<code>DELETE FROM table_name WHERE condition;</code></li></ul></li><li><strong>修改（Update）</strong><ul><li>使用<code>UPDATE</code>语句来修改表中已有的记录。同样需要使用<code>WHERE</code>子句来指定修改的条件。</li><li>例如：<code>UPDATE table_name SET column1 = new_value WHERE condition;</code></li></ul></li><li><strong>查询（Select）</strong><ul><li>使用<code>SELECT</code>语句来查询表中的数据。可以选择所有列或特定列，也可以使用各种条件来过滤结果。</li><li>例如：<code>SELECT column1, column2 FROM table_name WHERE condition;</code></li></ul></li></ol></li><li><h3 id="熟悉数据库运算符号"><a href="#熟悉数据库运算符号" class="headerlink" title="熟悉数据库运算符号"></a>熟悉数据库运算符号</h3><ol><li><em><strong>算术运算符</strong></em>：加（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）</li><li><strong>比较运算符</strong>：等于（&#x3D;）、大于（&gt;）、小于（&lt;）、大于等于（&gt;&#x3D;）、小于等于（&lt;&#x3D;）、不等于（!&#x3D;）</li><li><em><strong>逻辑运算符</strong></em>：逻辑非（！）、逻辑与（&amp;&amp;）、逻辑或（||）等</li><li><em><strong>位运算符</strong></em>：位与（&amp;）、位或（|）、位异或（^）、位取反（~）、位左移（&lt;&lt;）和位右移（&gt;&gt;）</li><li><em><strong>关系运算符</strong></em>：包括并（V）、差（^）等</li></ol></li><li><h3 id="常用函数的使用，sum，avg等"><a href="#常用函数的使用，sum，avg等" class="headerlink" title="常用函数的使用，sum，avg等"></a>常用函数的使用，sum，avg等</h3><h4 id="SUM函数"><a href="#SUM函数" class="headerlink" title="SUM函数"></a><strong>SUM函数</strong></h4><p>SUM函数用于计算某一单元格区域中数字之和。其语法为：SUM(number1, number2,…)，其中number1、number2等可以是数字、单元格引用或区域。</p><h4 id="AVG函数"><a href="#AVG函数" class="headerlink" title="AVG函数"></a><strong>AVG函数</strong></h4><p>AVG函数用于计算某一单元格区域中数字的平均值。其语法为：AVG(number1, number2,…)，其中number1、number2等可以是数字、单元格引用或区域。</p></li><li><h3 id="熟悉掌握和运用各种索引"><a href="#熟悉掌握和运用各种索引" class="headerlink" title="熟悉掌握和运用各种索引"></a>熟悉掌握和运用各种索引</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a><strong>索引类型</strong></h4><ol><li><em><strong>普通索引</strong></em>：最基础的索引类型，允许重复值和NULL值，适用于大多数查询场景。</li><li><em><strong>唯一索引</strong></em>：确保索引列中的值唯一，但允许有空值（NULL）。适用于需要确保数据唯一性但允许某些记录值缺失的场景。</li><li><em><strong>全文索引</strong></em>：用于对文本内容进行高效搜索，支持分词和模糊匹配。适用于搜索引擎和需要对大量文本数据进行搜索的场景。</li><li><em><strong>覆盖索引</strong></em>：查询中所需的所有列都包含在索引中，减少I&#x2F;O操作，提高查询效率。</li><li><em><strong>组合索引</strong></em>：由多个列的值组成，用于优化多列的组合查询。</li><li><em><strong>聚簇索引和非聚簇索引</strong></em>：聚簇索引定义了表中数据的物理存储方式，非聚簇索引独立于数据的物理存储。</li></ol><h4 id="索引的使用技巧"><a href="#索引的使用技巧" class="headerlink" title="索引的使用技巧"></a><strong>索引的使用技巧</strong></h4><ol><li><em><strong>避免全表扫描</strong></em>：在where及order by，group by涉及的列上建立索引。</li><li><em><strong>避免滥用索引</strong></em>：过多的索引会降低更新表的速度，并占用磁盘空间。</li><li><em><strong>避免使用!&#x3D;或&lt;&gt;操作符</strong></em>：否则将引擎放弃使用索引而进行全表扫描。</li><li><em><strong>避免在where子句中对字段进行null值判断</strong></em>：否则将导致引擎放弃使用索引而进行全表扫描。</li><li><em><strong>避免在where子句中使用or来连接条件</strong></em>：否则将导致引擎放弃使用索引而进行全表扫描。</li><li><em><strong>避免使用like通配符</strong></em>：当通配符位于字符串的开始位置（例如%keyword），MySQL可能无法利用索引进行快速查找。</li><li><em><strong>避免在索引列上使用内置函数</strong></em>：对索引列应用MySQL内置函数，会使得MySQL无法直接使用索引进行查找。</li><li><em><strong>避免在索引列上执行算术运算</strong></em>：在索引列上执行算术运算（如加、减、乘、除）会使得MySQL无法利用索引进行数据查找。</li></ol><h4 id="索引的应用场景"><a href="#索引的应用场景" class="headerlink" title="索引的应用场景"></a><strong>索引的应用场景</strong></h4><ol><li><em><strong>获取列表中特定位置的元素</strong></em>：通过索引快速获取列表中特定位置的元素。</li><li><em><strong>截取字符串的子串</strong></em>：使用字符串索引来截取子串。</li><li><em><strong>定位元组中的某个值</strong></em>：通过索引快速定位元组中的某个值。</li></ol></li><li><h3 id="数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group-by，having等"><a href="#数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group-by，having等" class="headerlink" title="数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group by，having等"></a>数据库表的查询操作，查询操作要熟练使用where，in，like，between…and…，group by，having等</h3><h4 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h4><p>WHERE子句用于过滤记录，即从表中选择满足指定条件的行。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这将返回所有部门ID为10的员工记录。</p><h4 id="IN子句"><a href="#IN子句" class="headerlink" title="IN子句"></a>IN子句</h4><p>IN子句允许您在WHERE子句中指定多个可能的值。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>这将返回部门ID为10、20或30的所有员工记录。</p><h4 id="LIKE子句"><a href="#LIKE子句" class="headerlink" title="LIKE子句"></a>LIKE子句</h4><p>LIKE子句用于在WHERE子句中搜索列中的指定模式。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> first_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;J%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这将返回所有名字以“J”开头的员工记录。</p><h4 id="BETWEEN…AND…子句"><a href="#BETWEEN…AND…子句" class="headerlink" title="BETWEEN…AND…子句"></a>BETWEEN…AND…子句</h4><p>BETWEEN…AND…子句用于在WHERE子句中选择介于两个值之间的范围。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> salary <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">50000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">100000</span>;<br></code></pre></td></tr></table></figure><p>这将返回所有薪资在50000到100000之间的员工记录。</p><h4 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h4><p>GROUP BY子句用于将表中的记录按照一个或多个列进行分组。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT department_id, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num_employees <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br></code></pre></td></tr></table></figure><p>这将返回每个部门的员工数量。</p><h4 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h4><p>HAVING子句用于在GROUP BY子句之后过滤分组结果。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlSELECT department_id, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num_employees <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>这将返回员工数量大于5的部门。</p></li><li><h3 id="要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作"><a href="#要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作" class="headerlink" title="要熟悉掌握left join,inner join,right join,cross jion 这些连表操作"></a>要熟悉掌握left join,inner join,right join,cross jion 这些连表操作</h3><ol><li><strong>INNER JOIN</strong><ul><li>返回两个表中满足连接条件的记录。如果某个表中的行在另一个表中没有匹配行，则这些行不会出现在结果集中。</li><li>例如：<code>SELECT * FROM TableA INNER JOIN TableB ON TableA.Key = TableB.Key</code>。</li></ul></li><li><strong>LEFT JOIN</strong><ul><li>返回左表的所有记录，以及右表中与左表匹配的记录。如果右表中没有匹配的记录，则右表的部分显示为NULL。</li><li>例如：<code>SELECT * FROM TableA LEFT JOIN TableB ON TableA.Key = TableB.Key</code>。</li></ul></li><li><strong>RIGHT JOIN</strong><ul><li>返回右表的所有记录，以及左表中与右表匹配的记录。如果左表中没有匹配的记录，则左表的部分显示为NULL。</li><li>例如：<code>SELECT * FROM TableA RIGHT JOIN TableB ON TableA.Key = TableB.Key</code>。</li></ul></li><li><strong>CROSS JOIN</strong><ul><li>返回两个表的笛卡尔积，即第一个表中的每一行与第二个表中的每一行组合生成一个新的行。如果第一个表有m行，第二个表有n行，则结果有m*n行。</li><li>例如：<code>SELECT * FROM TableA CROSS JOIN TableB</code>。</li></ul></li></ol></li></ol><p>力扣题目：</p><ol><li><a href="https://leetcode.cn/problems/combine-two-tables/description/">175. 组合两个表 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/employees-earning-more-than-their-managers/">181. 超过经理收入的员工 - 力扣（LeetCode）</a></li></ol><p>进阶：</p><ol><li><h3 id="索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？"><a href="#索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？" class="headerlink" title="索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？"></a>索引使用的什么数据结构，为什么采用这种数据结构不采用B树？什么是索引下推？什么是回表？</h3><ol><li><strong>磁盘IO效率</strong>：B+树的所有数据都存储在叶子节点，这使得查询时需要的磁盘IO次数更少，因为通常只需要访问叶子节点即可获取数据。B树的非叶子节点也存储数据，导致查询可能需要访问更多的层级，增加了IO成本。</li><li><strong>范围查询效率</strong>：B+树的叶子节点是双向链表，非常适合进行范围查询，因为一旦定位到起始点，可以通过链表顺序访问后续的相关数据。B树则需要在每次范围查询时从根节点重新开始遍历。</li><li><strong>稳定性</strong>：B+树的结构更加稳定，因为它的非叶子节点只存储索引信息，不存储实际数据，这使得树的结构在插入和删除操作时更加稳定，减少了树的重组频率。</li></ol><p>索引下推是一种优化技术，它允许在索引遍历过程中对索引中的数据进行过滤，从而减少需要回表查询的数据量。例如，如果有一个联合索引（如name和age），并且查询条件是name like ‘张%’ and age &gt; 10，索引下推会在索引层面对满足name条件的记录进一步筛选age条件，而不是先将所有满足name条件的记录回表后再进行筛选。</p><p>回表是指在非主键索引（也称为二级索引）的查询中，当通过索引找到匹配的记录后，还需要根据索引中存储的主键值返回到主键索引去查询完整的行数据。这是因为二级索引的叶子节点只存储了索引列和主键值，而不包含所有列的数据。</p></li><li><h3 id="要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作，要知道怎么连接的，并用韦恩图画出来。"><a href="#要熟悉掌握left-join-inner-join-right-join-cross-jion-这些连表操作，要知道怎么连接的，并用韦恩图画出来。" class="headerlink" title="要熟悉掌握left join,inner join,right join,cross jion 这些连表操作，要知道怎么连接的，并用韦恩图画出来。"></a>要熟悉掌握left join,inner join,right join,cross jion 这些连表操作，要知道怎么连接的，并用韦恩图画出来。</h3><p><strong>INNER JOIN</strong></p><ul><li>只返回两个表中满足连接条件的行。</li><li>如果某行在其中一个表中没有匹配，则不会出现在结果集中。</li><li>韦恩图表示：只有两个集合交集的部分。</li></ul><p><strong>LEFT JOIN (LEFT OUTER JOIN)</strong></p><ul><li>返回左表中的所有行，即使在右表中没有匹配的行。</li><li>如果右表中没有匹配的行，则结果集中的右表列将为NULL。</li><li>韦恩图表示：左表全部加上两个集合交集的部分。</li></ul><h5 id="RIGHT-JOIN-RIGHT-OUTER-JOIN"><a href="#RIGHT-JOIN-RIGHT-OUTER-JOIN" class="headerlink" title="RIGHT JOIN (RIGHT OUTER JOIN)"></a>RIGHT JOIN (RIGHT OUTER JOIN)</h5><ul><li>返回右表中的所有行，即使在左表中没有匹配的行。</li><li>如果左表中没有匹配的行，则结果集中的左表列将为NULL。</li><li>韦恩图表示：右表全部加上两个集合交集的部分。</li></ul><p><strong>CROSS JOIN</strong></p><ul><li>返回两个表的笛卡尔积，即第一个表的每一行与第二个表的每一行组合。</li><li>不需要指定连接条件，但结果集可能非常大。</li><li>韦恩图表示：两个集合的全部区域。</li></ul></li></ol><p>为了更直观地理解这些连接操作，可以使用韦恩图来表示不同<code>JOIN</code>类型所涵盖的数据范围：</p><ul><li><strong>INNER JOIN</strong>：两个圆的重叠部分。</li><li><strong>LEFT JOIN</strong>：左圆及其与右圆重叠的部分。</li><li><strong>RIGHT JOIN</strong>：右圆及其与左圆重叠的部分。</li><li><strong>CROSS JOIN</strong>：两个圆的全部区域，包括重叠部分和非重叠部分。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog/2025/01/14/hello-world/"/>
    <url>/blog/2025/01/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
